using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using HarmonyLib;
using UnityEngine;

// Namespace livre, apenas evite colisões
namespace Vini.Upgrade
{
    public class Loader
    {
        static Harmony _h;

        static Loader()
        {
            try
            {
                _h = new Harmony("vini.upgrade.button");
                _h.PatchAll();
                SdtdConsole.Instance?.Output("[Vini-UpgradeButton] Harmony patched.");
                UpgradeConfig.Load();
            }
            catch (Exception e)
            {
                SdtdConsole.Instance?.Output("[Vini-UpgradeButton] Error: " + e);
            }
        }
    }

    // ------------ Config ------------
    public static class UpgradeConfig
    {
        public class Cost
        {
            public string ItemName; public int Count;
            public bool IsDukes => ItemName == "$DUKES$";
        }
        public class Rule
        {
            public string Group;
            public int MaxQuality;
            public int QualityStep;
            public List<Cost> Costs = new();
        }
        public class TransformPath
        {
            public string From; public string To;
            public List<Cost> Costs = new();
        }

        public static List<Rule> Rules = new();
        public static List<TransformPath> Paths = new();

        public static void Load()
        {
            try
            {
                Rules.Clear(); Paths.Clear();

                var path = GamePrefs.GetString(EnumGamePrefs.GameDir) + "/Mods/Vini-UpgradeButton/Config/upgrade_rules.xml";
                var doc = new XmlDocument();
                doc.Load(path);

                foreach (XmlNode n in doc.SelectNodes("//upgrade/rule"))
                {
                    var r = new Rule
                    {
                        Group = n.Attributes["group"]?.Value ?? "weapons",
                        MaxQuality = int.Parse(n.Attributes["maxQuality"]?.Value ?? "6"),
                        QualityStep = int.Parse(n.SelectSingleNode("quality")?.Attributes["step"]?.Value ?? "1")
                    };
                    foreach (XmlNode c in n.SelectNodes("cost/item"))
                    {
                        r.Costs.Add(new Cost { ItemName = c.Attributes["name"].Value, Count = int.Parse(c.Attributes["count"].Value) });
                    }
                    var dukes = n.SelectSingleNode("cost/dukes");
                    if (dukes != null) r.Costs.Add(new Cost { ItemName = "$DUKES$", Count = int.Parse(dukes.Attributes["count"].Value) });
                    Rules.Add(r);
                }

                foreach (XmlNode n in doc.SelectNodes("//upgrade/transform/path"))
                {
                    var p = new TransformPath
                    {
                        From = n.SelectSingleNode("from")?.Attributes["name"]?.Value,
                        To = n.SelectSingleNode("to")?.Attributes["name"]?.Value
                    };
                    foreach (XmlNode c in n.SelectNodes("cost/item"))
                        p.Costs.Add(new Cost { ItemName = c.Attributes["name"].Value, Count = int.Parse(c.Attributes["count"].Value) });
                    Paths.Add(p);
                }

                SdtdConsole.Instance?.Output($"[Vini-UpgradeButton] Loaded {Rules.Count} rules, {Paths.Count} transform paths.");
            }
            catch (Exception e)
            {
                SdtdConsole.Instance?.Output("[Vini-UpgradeButton] Config load error: " + e.Message);
            }
        }
    }

    // ------------ XUi hook ------------
    // Botão com on_press="upgrade_item" dispara este handler
    [HarmonyPatch(typeof(XUiC_Button), "OnPress")]
    public class Patch_Button_OnPress
    {
        static bool Prefix(XUiC_Button __instance)
        {
            try
            {
                var val = __instance.GetAttribute<string>("on_press");
                if (!string.Equals(val, "upgrade_item", StringComparison.OrdinalIgnoreCase))
                    return true;

                // Descobrir o item atualmente inspecionado/selecionado
                var wnd = __instance.xui?.controller;
                if (wnd == null) return false;

                // Tenta achar o item holdado no painel de info
                ItemStack stack = GetInspectedItem(__instance);
                if (stack.IsEmpty())
                {
                    XUiUtilities.ShowMessage(__instance.xui, "xuiUpgradeFail");
                    return false;
                }

                if (TryDoUpgrade(__instance, ref stack))
                {
                    XUiUtilities.ShowMessage(__instance.xui, "xuiUpgradeOk");
                    RefreshUI(__instance);
                }
                else
                {
                    XUiUtilities.ShowMessage(__instance.xui, "xuiUpgradeFail");
                }

                return false; // Consumimos o clique
            }
            catch (Exception e)
            {
                SdtdConsole.Instance?.Output("[Vini-UpgradeButton] OnPress error: " + e);
                return true;
            }
        }

        static ItemStack GetInspectedItem(XUiC_Button btn)
        {
            // Estratégia: procurar parents comuns que guardam o ItemValue mostrado
            // Muitos painéis de item expõem binding "itemstack" em XUi.
            // Tentativa genérica:
            var group = btn.xui?.ui?.currentSelectedItemStack;
            if (group.HasValue) return group.Value;

            // Fallback: tenta pegar do jogador item na mão
            var lp = GameManager.Instance.World?.GetPrimaryPlayer();
            if (lp != null) return lp.inventory.holdingItemItemValue.CreateItemStack();

            return ItemStack.Empty;
        }

        static bool TryDoUpgrade(XUiC_Button ctx, ref ItemStack stack)
        {
            var player = GameManager.Instance.World.GetPrimaryPlayer();
            if (player == null) return false;

            // 1) Transform path (variante) tem prioridade
            var path = UpgradeConfig.Paths.FirstOrDefault(p => string.Equals(p.From, stack.itemValue.ItemClass.Name, StringComparison.OrdinalIgnoreCase));
            if (path != null)
                return TryTransform(player, ref stack, path);

            // 2) Regras por grupo (qualidade + custo)
            string grp = InferGroup(stack.itemValue);
            var rule = UpgradeConfig.Rules.FirstOrDefault(r => r.Group == grp) ?? UpgradeConfig.Rules.FirstOrDefault(r => r.Group == "weapons");
            if (rule == null) return false;

            int curQ = stack.itemValue.Quality;
            if (curQ >= rule.MaxQuality) return false;

            var costs = ResolveCosts(rule.Costs, stack.itemValue);
            if (!HasCosts(player, costs)) return false;

            ConsumeCosts(player, costs);
            var iv = stack.itemValue;
            iv.Quality = Mathf.Clamp(curQ + rule.QualityStep, 1, rule.MaxQuality);
            stack = new ItemStack(iv, stack.count);
            ReplaceHeldOrContainerItem(player, stack);
            return true;
        }

        static bool TryTransform(EntityPlayerLocal player, ref ItemStack stack, UpgradeConfig.TransformPath path)
        {
            var toClass = ItemClass.GetItemClass(path.To, true);
            if (toClass == null) return false;

            if (!HasCosts(player, path.Costs)) return false;
            ConsumeCosts(player, path.Costs);

            var newIv = new ItemValue(toClass.Id, quality: Math.Max(1, stack.itemValue.Quality));
            var newStack = new ItemStack(newIv, stack.count);

            ReplaceHeldOrContainerItem(player, newStack);
            stack = newStack;
            return true;
        }

        static string InferGroup(ItemValue iv)
        {
            var ic = iv.ItemClass;
            if (ic == null) return "weapons";
            if (ic.ItemTags != null && ic.ItemTags.Test_AnySet(ItemClass.TagEnum.LargeTool | ItemClass.TagEnum.Tool)) return "tools";
            if (ic.ItemTags != null && ic.ItemTags.Test_AnySet(ItemClass.TagEnum.Gun | ItemClass.TagEnum.Melee)) return "weapons";
            return "weapons";
        }

        static List<UpgradeConfig.Cost> ResolveCosts(List<UpgradeConfig.Cost> costs, ItemValue iv)
        {
            var resolved = new List<UpgradeConfig.Cost>();
            foreach (var c in costs)
            {
                if (c.IsDukes) { resolved.Add(c); continue; }
                if (c.ItemName == "@parts")
                {
                    var parts = MapPartsFor(iv);
                    resolved.Add(new UpgradeConfig.Cost { ItemName = parts, Count = c.Count });
                }
                else resolved.Add(c);
            }
            return resolved;
        }

        static string MapPartsFor(ItemValue iv)
        {
            var name = iv.ItemClass?.Name ?? "";
            // Mapeamento simples (exemplos comuns — personalize conforme seu set)
            if (name.Contains("Pistol", StringComparison.OrdinalIgnoreCase)) return "partsPistol";
            if (name.Contains("Shotgun", StringComparison.OrdinalIgnoreCase)) return "partsShotgun";
            if (name.Contains("Rifle", StringComparison.OrdinalIgnoreCase)) return "partsRifle";
            if (name.Contains("Machinegun", StringComparison.OrdinalIgnoreCase)) return "partsMachineGun";
            if (name.Contains("Revolver", StringComparison.OrdinalIgnoreCase) || name.Contains("Magnum", StringComparison.OrdinalIgnoreCase)) return "partsMagnum";
            if (name.Contains("Bow", StringComparison.OrdinalIgnoreCase) || name.Contains("Crossbow", StringComparison.OrdinalIgnoreCase)) return "partsBow";
            // Ferramentas:
            if (name.Contains("Axe", StringComparison.OrdinalIgnoreCase)) return "partsTool";
            if (name.Contains("Pick", StringComparison.OrdinalIgnoreCase)) return "partsTool";
            return "resourceRepairKit"; // fallback “neutro”
        }

        static bool HasCosts(EntityPlayerLocal p, List<UpgradeConfig.Cost> costs)
        {
            foreach (var c in costs)
            {
                if (c.IsDukes)
                {
                    if (p.inventory.GetDukesAmount() < c.Count) return false;
                }
                else
                {
                    if (p.bag.GetItemCount(ItemClass.GetItem(c.ItemName).itemValue) < c.Count &&
                        p.inventory.GetItemCount(ItemClass.GetItem(c.ItemName).itemValue) < c.Count)
                        return false;
                }
            }
            return true;
        }

        static void ConsumeCosts(EntityPlayerLocal p, List<UpgradeConfig.Cost> costs)
        {
            foreach (var c in costs)
            {
                if (c.IsDukes)
                {
                    p.inventory.ModifyDukes(-c.Count);
                }
                else
                {
                    var iv = ItemClass.GetItem(c.ItemName).itemValue;
                    int remaining = c.Count;
                    remaining = RemoveFrom(p.bag, iv, remaining);
                    if (remaining > 0) RemoveFrom(p.inventory, iv, remaining);
                }
            }
        }

        static int RemoveFrom(Inventory inv, ItemValue iv, int count)
        {
            int left = count;
            for (int i = 0; i < inv.capacity && left > 0; i++)
            {
                var st = inv.GetItem(i);
                if (!st.IsEmpty() && st.itemValue.type == iv.type)
                {
                    int take = Math.Min(st.count, left);
                    st.count -= take;
                    if (st.count <= 0) inv.SetItem(i, ItemStack.Empty);
                    else inv.SetItem(i, st);
                    left -= take;
                }
            }
            return left;
        }

        static void ReplaceHeldOrContainerItem(EntityPlayerLocal p, ItemStack newStack)
        {
            // Se o jogador estiver com o item na mão, substitui
            var hi = p.inventory.holdingItemItemValue;
            if (!hi.IsEmpty() && hi.type == newStack.itemValue.type)
            {
                p.inventory.SetItem(p.inventory.holdingItemIdx, newStack);
                return;
            }

            // Caso esteja vindo de um container/slot selecionado no UI, tenta atualizar slot atual
            // (fallback genérico: apenas dá o item e remove 1 do antigo)
            p.inventory.AddItem(newStack, true);
        }

        static void RefreshUI(XUiC_Button ctx)
        {
            ctx.xui?.playerUI?.windowManager?.Open("item_info", true, false); // “pulse” abre/fecha
            ctx.xui?.playerUI?.windowManager?.Close("item_info");
            ctx.xui?.playerUI?.windowManager?.Open("item_info");
        }
    }

    // Utilitário simples de Toast (usa Localization keys)
    public static class XUiUtilities
    {
        public static void ShowMessage(XUi xui, string locKey)
        {
            try
            {
                var msg = Localization.Get(locKey);
                xui?.playerUI?.logWindow?.AddText(msg);
            }
            catch { }
        }
    }
}
